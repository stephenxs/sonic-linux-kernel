From d26dfbed5bacbb6b155b9545180e316356b3ac5f Mon Sep 17 00:00:00 2001
From: Vadim Pasternak <vadimp@mellanox.com>
Date: Thu, 12 Mar 2020 14:12:08 +0200
Subject: [v4.19-6 backport 2/2] v4.19-6: Mellanox platform: Additional
 backport for new Mellanox systems

It contains backport patches from v5.* kernels:
- Adding module for ethtool support.
- Changing Mellanox i2c bus poling time frequency.
- Watchdog Mellanox driver.

Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
---
 drivers/i2c/busses/i2c-mlxcpld.c              |   2 +-
 .../net/ethernet/mellanox/mlxsw/core_env.c    | 256 ++++++++++
 .../net/ethernet/mellanox/mlxsw/core_env.h    |  17 +
 .../net/ethernet/mellanox/mlxsw/qsfp_sysfs.c  | 454 ++++++++++++++++++
 drivers/watchdog/mlx_wdt.c                    | 289 +++++++++++
 5 files changed, 1017 insertions(+), 1 deletion(-)
 create mode 100644 drivers/net/ethernet/mellanox/mlxsw/core_env.c
 create mode 100644 drivers/net/ethernet/mellanox/mlxsw/core_env.h
 create mode 100644 drivers/net/ethernet/mellanox/mlxsw/qsfp_sysfs.c
 create mode 100644 drivers/watchdog/mlx_wdt.c

diff --git a/drivers/i2c/busses/i2c-mlxcpld.c b/drivers/i2c/busses/i2c-mlxcpld.c
index 41b57027e..6da4b58ee 100644
--- a/drivers/i2c/busses/i2c-mlxcpld.c
+++ b/drivers/i2c/busses/i2c-mlxcpld.c
@@ -51,7 +51,7 @@
 #define MLXCPLD_I2C_MAX_ADDR_LEN	4
 #define MLXCPLD_I2C_RETR_NUM		2
 #define MLXCPLD_I2C_XFER_TO		500000 /* usec */
-#define MLXCPLD_I2C_POLL_TIME		200   /* usec */
+#define MLXCPLD_I2C_POLL_TIME		400   /* usec */
 
 /* LPC I2C registers */
 #define MLXCPLD_LPCI2C_CPBLTY_REG	0x0
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core_env.c b/drivers/net/ethernet/mellanox/mlxsw/core_env.c
new file mode 100644
index 000000000..03eae1ed2
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlxsw/core_env.c
@@ -0,0 +1,256 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
+/* Copyright (c) 2018 Mellanox Technologies. All rights reserved */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/sfp.h>
+
+#include "core.h"
+#include "core_env.h"
+#include "item.h"
+#include "reg.h"
+
+static int mlxsw_env_validate_cable_ident(struct mlxsw_core *core, int id,
+					  bool *qsfp)
+{
+	char eeprom_tmp[MLXSW_REG_MCIA_EEPROM_SIZE];
+	char mcia_pl[MLXSW_REG_MCIA_LEN];
+	u8 ident;
+	int err;
+
+	mlxsw_reg_mcia_pack(mcia_pl, id, 0, MLXSW_REG_MCIA_PAGE0_LO_OFF, 0, 1,
+			    MLXSW_REG_MCIA_I2C_ADDR_LOW);
+	err = mlxsw_reg_query(core, MLXSW_REG(mcia), mcia_pl);
+	if (err)
+		return err;
+	mlxsw_reg_mcia_eeprom_memcpy_from(mcia_pl, eeprom_tmp);
+	ident = eeprom_tmp[0];
+	switch (ident) {
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_SFP:
+		*qsfp = false;
+		break;
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP: /* fall-through */
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS: /* fall-through */
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28: /* fall-through */
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_DD: /* fall-through */
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_SFP_DD: /* fall-through */
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS_CMIS:
+		*qsfp = true;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+mlxsw_env_query_module_eeprom(struct mlxsw_core *mlxsw_core, int module,
+			      u16 offset, u16 size, bool qsfp, void *data,
+			      unsigned int *p_read_size)
+{
+	char eeprom_tmp[MLXSW_REG_MCIA_EEPROM_SIZE];
+	char mcia_pl[MLXSW_REG_MCIA_LEN];
+	u16 i2c_addr;
+	u8 page = 0;
+	int status;
+	int err;
+
+	size = min_t(u16, size, MLXSW_REG_MCIA_EEPROM_SIZE);
+
+	if (offset < MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH &&
+	    offset + size > MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH)
+		/* Cross pages read, read until offset 256 in low page */
+		size = MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH - offset;
+
+	i2c_addr = MLXSW_REG_MCIA_I2C_ADDR_LOW;
+	if (offset >= MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH) {
+		if (qsfp) {
+			page = MLXSW_REG_MCIA_PAGE_GET(offset);
+			offset -= MLXSW_REG_MCIA_EEPROM_UP_PAGE_LENGTH * page;
+			if (offset + size > MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH)
+				size = MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH -
+				       offset;
+		} else {
+			i2c_addr = MLXSW_REG_MCIA_I2C_ADDR_HIGH;
+			offset -= MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH;
+		}
+	}
+
+	mlxsw_reg_mcia_pack(mcia_pl, module, 0, page, offset, size, i2c_addr);
+
+	err = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mcia), mcia_pl);
+	if (err)
+		return err;
+
+	status = mlxsw_reg_mcia_status_get(mcia_pl);
+	if (status)
+		return -EIO;
+
+	mlxsw_reg_mcia_eeprom_memcpy_from(mcia_pl, eeprom_tmp);
+	memcpy(data, eeprom_tmp, size);
+	*p_read_size = size;
+
+	return 0;
+}
+
+int mlxsw_env_module_temp_thresholds_get(struct mlxsw_core *core, int module,
+					 int off, int *temp)
+{
+	char eeprom_tmp[MLXSW_REG_MCIA_EEPROM_SIZE];
+	union {
+		u8 buf[MLXSW_REG_MCIA_TH_ITEM_SIZE];
+		u16 temp;
+	} temp_thresh;
+	char mcia_pl[MLXSW_REG_MCIA_LEN] = {0};
+	char mtmp_pl[MLXSW_REG_MTMP_LEN];
+	unsigned int module_temp;
+	bool qsfp;
+	int err;
+
+	mlxsw_reg_mtmp_pack(mtmp_pl, MLXSW_REG_MTMP_MODULE_INDEX_MIN + module,
+			    false, false);
+	err = mlxsw_reg_query(core, MLXSW_REG(mtmp), mtmp_pl);
+	if (err)
+		return err;
+	mlxsw_reg_mtmp_unpack(mtmp_pl, &module_temp, NULL, NULL);
+	if (!module_temp) {
+		*temp = 0;
+		return 0;
+	}
+
+	/* Read Free Side Device Temperature Thresholds from page 03h
+	 * (MSB at lower byte address).
+	 * Bytes:
+	 * 128-129 - Temp High Alarm (SFP_TEMP_HIGH_ALARM);
+	 * 130-131 - Temp Low Alarm (SFP_TEMP_LOW_ALARM);
+	 * 132-133 - Temp High Warning (SFP_TEMP_HIGH_WARN);
+	 * 134-135 - Temp Low Warning (SFP_TEMP_LOW_WARN);
+	 */
+
+	/* Validate module identifier value. */
+	err = mlxsw_env_validate_cable_ident(core, module, &qsfp);
+	if (err)
+		return err;
+
+	if (qsfp)
+		mlxsw_reg_mcia_pack(mcia_pl, module, 0,
+				    MLXSW_REG_MCIA_TH_PAGE_NUM,
+				    MLXSW_REG_MCIA_TH_PAGE_OFF + off,
+				    MLXSW_REG_MCIA_TH_ITEM_SIZE,
+				    MLXSW_REG_MCIA_I2C_ADDR_LOW);
+	else
+		mlxsw_reg_mcia_pack(mcia_pl, module, 0,
+				    MLXSW_REG_MCIA_PAGE0_LO,
+				    off, MLXSW_REG_MCIA_TH_ITEM_SIZE,
+				    MLXSW_REG_MCIA_I2C_ADDR_HIGH);
+
+	err = mlxsw_reg_query(core, MLXSW_REG(mcia), mcia_pl);
+	if (err)
+		return err;
+
+	mlxsw_reg_mcia_eeprom_memcpy_from(mcia_pl, eeprom_tmp);
+	memcpy(temp_thresh.buf, eeprom_tmp, MLXSW_REG_MCIA_TH_ITEM_SIZE);
+	*temp = temp_thresh.temp * 1000;
+
+	return 0;
+}
+
+int mlxsw_env_get_module_info(struct mlxsw_core *mlxsw_core, int module,
+			      struct ethtool_modinfo *modinfo)
+{
+	u8 module_info[MLXSW_REG_MCIA_EEPROM_MODULE_INFO_SIZE];
+	u16 offset = MLXSW_REG_MCIA_EEPROM_MODULE_INFO_SIZE;
+	u8 module_rev_id, module_id, diag_mon;
+	unsigned int read_size;
+	int err;
+
+	err = mlxsw_env_query_module_eeprom(mlxsw_core, module, 0, offset,
+					    false, module_info, &read_size);
+	if (err)
+		return err;
+
+	if (read_size < offset)
+		return -EIO;
+
+	module_rev_id = module_info[MLXSW_REG_MCIA_EEPROM_MODULE_INFO_REV_ID];
+	module_id = module_info[MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID];
+
+	switch (module_id) {
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP:
+		modinfo->type       = ETH_MODULE_SFF_8436;
+		modinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;
+		break;
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS: /* fall-through */
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28:
+		if (module_id == MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28 ||
+		    module_rev_id >=
+		    MLXSW_REG_MCIA_EEPROM_MODULE_INFO_REV_ID_8636) {
+			modinfo->type       = ETH_MODULE_SFF_8636;
+			modinfo->eeprom_len = ETH_MODULE_SFF_8636_MAX_LEN;
+		} else {
+			modinfo->type       = ETH_MODULE_SFF_8436;
+			modinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;
+		}
+		break;
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_SFP:
+		/* Verify if transceiver provides diagnostic monitoring page */
+		err = mlxsw_env_query_module_eeprom(mlxsw_core, module,
+						    SFP_DIAGMON, 1, false,
+						    &diag_mon, &read_size);
+		if (err)
+			return err;
+
+		if (read_size < 1)
+			return -EIO;
+
+		modinfo->type       = ETH_MODULE_SFF_8472;
+		if (diag_mon)
+			modinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;
+		else
+			modinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN / 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mlxsw_env_get_module_info);
+
+int mlxsw_env_get_module_eeprom(struct net_device *netdev,
+				struct mlxsw_core *mlxsw_core, int module,
+				struct ethtool_eeprom *ee, u8 *data)
+{
+	int offset = ee->offset;
+	unsigned int read_size;
+	bool qsfp;
+	int i = 0;
+	int err;
+
+	if (!ee->len)
+		return -EINVAL;
+
+	memset(data, 0, ee->len);
+
+	/* Validate module identifier type. */
+	err = mlxsw_env_validate_cable_ident(mlxsw_core, module, &qsfp);
+	if (err)
+		return err;
+
+	while (i < ee->len) {
+		err = mlxsw_env_query_module_eeprom(mlxsw_core, module, offset,
+						    ee->len - i, qsfp,
+						    data + i, &read_size);
+		if (err) {
+			netdev_err(netdev, "Eeprom query failed\n");
+			return err;
+		}
+
+		i += read_size;
+		offset += read_size;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mlxsw_env_get_module_eeprom);
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core_env.h b/drivers/net/ethernet/mellanox/mlxsw/core_env.h
new file mode 100644
index 000000000..064d0e770
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlxsw/core_env.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0 */
+/* Copyright (c) 2018 Mellanox Technologies. All rights reserved */
+
+#ifndef _MLXSW_CORE_ENV_H
+#define _MLXSW_CORE_ENV_H
+
+int mlxsw_env_module_temp_thresholds_get(struct mlxsw_core *core, int module,
+					 int off, int *temp);
+
+int mlxsw_env_get_module_info(struct mlxsw_core *mlxsw_core, int module,
+			      struct ethtool_modinfo *modinfo);
+
+int mlxsw_env_get_module_eeprom(struct net_device *netdev,
+				struct mlxsw_core *mlxsw_core, int module,
+				struct ethtool_eeprom *ee, u8 *data);
+
+#endif
diff --git a/drivers/net/ethernet/mellanox/mlxsw/qsfp_sysfs.c b/drivers/net/ethernet/mellanox/mlxsw/qsfp_sysfs.c
new file mode 100644
index 000000000..49563a703
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlxsw/qsfp_sysfs.c
@@ -0,0 +1,454 @@
+/*
+ * drivers/net/ethernet/mellanox/mlxsw/qsfp_sysfs.c
+ * Copyright (c) 2017 Mellanox Technologies. All rights reserved.
+ * Copyright (c) 2017 Vadim Pasternak <vadimp@mellanox.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/device.h>
+#include <linux/dmi.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/sysfs.h>
+#include <linux/types.h>
+
+#include "core.h"
+
+#define MLXSW_QSFP_I2C_ADDR		0x50
+#define MLXSW_QSFP_PAGE_NUM		5
+#define MLXSW_QSFP_PAGE_SIZE		128
+#define MLXSW_QSFP_SUB_PAGE_NUM		3
+#define MLXSW_QSFP_SUB_PAGE_SIZE	48
+#define MLXSW_QSFP_LAST_SUB_PAGE_SIZE	32
+#define MLXSW_QSFP_MAX_NUM		128
+#define MLXSW_QSFP_MIN_REQ_LEN		4
+#define MLXSW_QSFP_STATUS_VALID_TIME	(HZ)
+#define MLXSW_QSFP_MAX_CPLD_NUM		3
+#define MLXSW_QSFP_MIN_CPLD_NUM		1
+
+static const u8 mlxsw_qsfp_page_number[] = { 0xa0, 0x00, 0x01, 0x02, 0x03 };
+static const u16 mlxsw_qsfp_page_shift[] = { 0x00, 0x80, 0x80, 0x80, 0x80 };
+
+/**
+ * Mellanox device Management Cable Info Access Register buffer for reading
+ * QSFP EEPROM info is limited by 48 bytes. In case full page is to be read
+ * (128 bytes), such request will be implemented by three transactions of size
+ * 48, 48, 32.
+ */
+static const u16 mlxsw_qsfp_sub_page_size[] = {
+	MLXSW_QSFP_SUB_PAGE_SIZE,
+	MLXSW_QSFP_SUB_PAGE_SIZE,
+	MLXSW_QSFP_LAST_SUB_PAGE_SIZE
+};
+
+struct mlxsw_qsfp_module {
+	unsigned long last_updated;
+	u8 cache_status;
+};
+
+struct mlxsw_qsfp {
+	struct mlxsw_core *core;
+	const struct mlxsw_bus_info *bus_info;
+	struct attribute *attrs[MLXSW_QSFP_MAX_NUM + 1];
+	struct device_attribute *dev_attrs;
+	struct bin_attribute *eeprom;
+	struct bin_attribute **eeprom_attr_list;
+	struct mlxsw_qsfp_module modules[MLXSW_QSFP_MAX_NUM];
+	u8 module_ind[MLXSW_QSFP_MAX_NUM];
+	u8 module_count;
+	struct attribute *cpld_attrs[MLXSW_QSFP_MAX_CPLD_NUM + 1];
+	struct device_attribute *cpld_dev_attrs;
+};
+
+static int mlxsw_qsfp_cpld_num = MLXSW_QSFP_MIN_CPLD_NUM;
+static int mlxsw_qsfp_num = MLXSW_QSFP_MAX_NUM / 2;
+
+static int
+mlxsw_qsfp_query_module_eeprom(struct mlxsw_qsfp *mlxsw_qsfp, u8 index,
+			       loff_t off, size_t count, int page, char *buf)
+{
+	char eeprom_tmp[MLXSW_QSFP_PAGE_SIZE];
+	char mcia_pl[MLXSW_REG_MCIA_LEN];
+	int status;
+	int err;
+
+	mlxsw_reg_mcia_pack(mcia_pl, index, 0, page, off, count,
+			    MLXSW_QSFP_I2C_ADDR);
+
+	err = mlxsw_reg_query(mlxsw_qsfp->core, MLXSW_REG(mcia), mcia_pl);
+	if (err)
+		return err;
+
+	status = mlxsw_reg_mcia_status_get(mcia_pl);
+	if (status)
+		return -EIO;
+
+	mlxsw_reg_mcia_eeprom_memcpy_from(mcia_pl, eeprom_tmp);
+	memcpy(buf, eeprom_tmp, count);
+
+	return 0;
+}
+
+static int
+mlxsw_qsfp_get_module_eeprom(struct mlxsw_qsfp *mlxsw_qsfp, u8 index,
+			     char *buf, loff_t off, size_t count)
+{
+	int page_ind, page, page_off, subpage, offset, size, res = 0;
+	int err;
+
+	if (!count)
+		return -EINVAL;
+
+	memset(buf, 0, count);
+	size = count;
+	while (res < count) {
+		page_ind = off / MLXSW_QSFP_PAGE_SIZE;
+		page_off = off % MLXSW_QSFP_PAGE_SIZE;
+		page = mlxsw_qsfp_page_number[page_ind];
+		offset = mlxsw_qsfp_page_shift[page_ind] + page_off;
+		subpage = page_off / MLXSW_QSFP_SUB_PAGE_SIZE;
+		size = min_t(u16, size, mlxsw_qsfp_sub_page_size[subpage]);
+		err = mlxsw_qsfp_query_module_eeprom(mlxsw_qsfp, index, offset,
+						     size, page, buf + res);
+		if (err) {
+			dev_err(mlxsw_qsfp->bus_info->dev, "Eeprom query failed\n");
+			return err;
+		}
+		off += size;
+		res += size;
+		size = count - size;
+	}
+
+	return res;
+}
+
+static ssize_t mlxsw_qsfp_bin_read(struct file *filp, struct kobject *kobj,
+				   struct bin_attribute *attr, char *buf,
+				   loff_t off, size_t count)
+{
+	struct mlxsw_qsfp *mlxsw_qsfp = dev_get_platdata(container_of(kobj,
+							 struct device, kobj));
+	u8 *module_ind = attr->private;
+	size_t size;
+
+	size = mlxsw_qsfp->eeprom[*module_ind].size;
+
+	if (off > size)
+		return -ESPIPE;
+	else if (off == size)
+		return 0;
+	else if ((off + count) > size)
+		count = size - off;
+
+	return mlxsw_qsfp_get_module_eeprom(mlxsw_qsfp, *module_ind, buf, off,
+					    count);
+}
+
+static ssize_t
+mlxsw_qsfp_status_show(struct device *dev, struct device_attribute *attr,
+		       char *buf)
+{
+	struct mlxsw_qsfp *mlxsw_qsfp = dev_get_platdata(dev);
+	char mcia_pl[MLXSW_REG_MCIA_LEN];
+	int status;
+	u32 i;
+	int err;
+
+	for (i = 0; i < mlxsw_qsfp->module_count; i++) {
+		if ((mlxsw_qsfp->dev_attrs + i) == attr)
+			break;
+	}
+	if (i == mlxsw_qsfp->module_count)
+		return -EINVAL;
+
+	if (time_before(jiffies, mlxsw_qsfp->modules[i].last_updated +
+			MLXSW_QSFP_STATUS_VALID_TIME))
+		return sprintf(buf, "%u\n",
+			       mlxsw_qsfp->modules[i].cache_status);
+
+	mlxsw_reg_mcia_pack(mcia_pl, i, 0, 0, 0, MLXSW_QSFP_MIN_REQ_LEN,
+			    MLXSW_QSFP_I2C_ADDR);
+	err = mlxsw_reg_query(mlxsw_qsfp->core, MLXSW_REG(mcia), mcia_pl);
+	if (err)
+		return err;
+
+	status = mlxsw_reg_mcia_status_get(mcia_pl);
+	mlxsw_qsfp->modules[i].cache_status = !status;
+	mlxsw_qsfp->modules[i].last_updated = jiffies;
+
+	return sprintf(buf, "%u\n", !status);
+}
+
+static ssize_t
+mlxsw_qsfp_cpld_show(struct device *dev, struct device_attribute *attr,
+		     char *buf)
+{
+	struct mlxsw_qsfp *mlxsw_qsfp = dev_get_platdata(dev);
+	char msci_pl[MLXSW_REG_MSCI_LEN];
+	u32 version, i;
+	int err;
+
+	for (i = 0; i < mlxsw_qsfp_cpld_num; i++) {
+		if ((mlxsw_qsfp->cpld_dev_attrs + i) == attr)
+			break;
+	}
+	if (i == mlxsw_qsfp_cpld_num)
+		return -EINVAL;
+
+	mlxsw_reg_msci_pack(msci_pl, i);
+	err = mlxsw_reg_query(mlxsw_qsfp->core, MLXSW_REG(msci), msci_pl);
+	if (err)
+		return err;
+
+	version = mlxsw_reg_msci_version_get(msci_pl);
+
+	return sprintf(buf, "%u\n", version);
+}
+
+static int mlxsw_qsfp_dmi_set_cpld_num(const struct dmi_system_id *dmi)
+{
+	mlxsw_qsfp_cpld_num = MLXSW_QSFP_MAX_CPLD_NUM;
+
+	return 1;
+};
+
+static int mlxsw_qsfp_dmi_set_qsfp_num(const struct dmi_system_id *dmi)
+{
+	mlxsw_qsfp_num = MLXSW_QSFP_MAX_NUM;
+
+	return 1;
+};
+
+static const struct dmi_system_id mlxsw_qsfp_dmi_table[] = {
+	{
+		.callback = mlxsw_qsfp_dmi_set_cpld_num,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Mellanox Technologies"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "MSN24"),
+		},
+	},
+	{
+		.callback = mlxsw_qsfp_dmi_set_cpld_num,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Mellanox Technologies"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "MSN27"),
+		},
+	},
+	{
+		.callback = mlxsw_qsfp_dmi_set_qsfp_num,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Mellanox Technologies"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "MSN37"),
+		},
+	},
+	{
+		.callback = mlxsw_qsfp_dmi_set_qsfp_num,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Mellanox Technologies"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "MSN38"),
+		},
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(dmi, mlxsw_qsfp_dmi_table);
+
+static int mlxsw_qsfp_set_module_num(struct mlxsw_qsfp *mlxsw_qsfp)
+{
+	char pmlp_pl[MLXSW_REG_PMLP_LEN];
+	u8 width;
+	int i, err;
+
+	for (i = 1; i <= mlxsw_qsfp_num; i++) {
+		mlxsw_reg_pmlp_pack(pmlp_pl, i);
+		err = mlxsw_reg_query(mlxsw_qsfp->core, MLXSW_REG(pmlp),
+				      pmlp_pl);
+		if (err)
+			return err;
+		width = mlxsw_reg_pmlp_width_get(pmlp_pl);
+		if (!width)
+			continue;
+		mlxsw_qsfp->module_count++;
+	}
+
+	return 0;
+}
+
+int mlxsw_qsfp_init(struct mlxsw_core *mlxsw_core,
+		    const struct mlxsw_bus_info *mlxsw_bus_info,
+		    struct mlxsw_qsfp **p_qsfp)
+{
+	struct device_attribute *dev_attr, *cpld_dev_attr;
+	char mgpir_pl[MLXSW_REG_MGPIR_LEN];
+	struct mlxsw_qsfp *mlxsw_qsfp;
+	struct bin_attribute *eeprom;
+	int i, count;
+	int err;
+
+	if (!strcmp(mlxsw_bus_info->device_kind, "i2c"))
+		return 0;
+
+	dmi_check_system(mlxsw_qsfp_dmi_table);
+
+	mlxsw_qsfp = devm_kzalloc(mlxsw_bus_info->dev, sizeof(*mlxsw_qsfp),
+				  GFP_KERNEL);
+	if (!mlxsw_qsfp)
+		return -ENOMEM;
+
+	mlxsw_qsfp->core = mlxsw_core;
+	mlxsw_qsfp->bus_info = mlxsw_bus_info;
+	mlxsw_bus_info->dev->platform_data = mlxsw_qsfp;
+
+	mlxsw_reg_mgpir_pack(mgpir_pl);
+	err = mlxsw_reg_query(mlxsw_qsfp->core, MLXSW_REG(mgpir), mgpir_pl);
+	if (err) {
+		err = mlxsw_qsfp_set_module_num(mlxsw_qsfp);
+		if (err)
+			return err;
+	} else {
+		mlxsw_reg_mgpir_unpack(mgpir_pl, NULL, NULL, NULL,
+			       &mlxsw_qsfp->module_count);
+		if (!mlxsw_qsfp->module_count)
+			return 0;
+	}
+
+	count = mlxsw_qsfp->module_count + 1;
+	mlxsw_qsfp->eeprom = devm_kzalloc(mlxsw_bus_info->dev,
+					  mlxsw_qsfp->module_count *
+					  sizeof(*mlxsw_qsfp->eeprom),
+					  GFP_KERNEL);
+	if (!mlxsw_qsfp->eeprom)
+		return -ENOMEM;
+
+	mlxsw_qsfp->eeprom_attr_list = devm_kzalloc(mlxsw_bus_info->dev,
+						    count *
+						    sizeof(mlxsw_qsfp->eeprom),
+						    GFP_KERNEL);
+	if (!mlxsw_qsfp->eeprom_attr_list)
+		return -ENOMEM;
+
+	mlxsw_qsfp->dev_attrs = devm_kzalloc(mlxsw_bus_info->dev, count *
+					     sizeof(*mlxsw_qsfp->dev_attrs),
+					     GFP_KERNEL);
+	if (!mlxsw_qsfp->dev_attrs)
+		return -ENOMEM;
+
+	mlxsw_qsfp->cpld_dev_attrs = devm_kzalloc(mlxsw_bus_info->dev,
+					mlxsw_qsfp_cpld_num *
+					sizeof(*mlxsw_qsfp->cpld_dev_attrs),
+					GFP_KERNEL);
+	if (!mlxsw_qsfp->cpld_dev_attrs)
+		return -ENOMEM;
+
+	eeprom = mlxsw_qsfp->eeprom;
+	dev_attr = mlxsw_qsfp->dev_attrs;
+	for (i = 0; i < mlxsw_qsfp->module_count; i++, eeprom++, dev_attr++) {
+		dev_attr->show = mlxsw_qsfp_status_show;
+		dev_attr->attr.mode = 0444;
+		dev_attr->attr.name = devm_kasprintf(mlxsw_bus_info->dev,
+						     GFP_KERNEL,
+						     "qsfp%d_status", i + 1);
+		mlxsw_qsfp->attrs[i] = &dev_attr->attr;
+		sysfs_attr_init(&dev_attr->attr);
+		err = sysfs_create_file(&mlxsw_bus_info->dev->kobj,
+					mlxsw_qsfp->attrs[i]);
+		if (err)
+			goto err_create_file;
+
+		sysfs_bin_attr_init(eeprom);
+		eeprom->attr.name = devm_kasprintf(mlxsw_bus_info->dev,
+						   GFP_KERNEL, "qsfp%d",
+						   i + 1);
+		eeprom->attr.mode = 0444;
+		eeprom->read = mlxsw_qsfp_bin_read;
+		eeprom->size = MLXSW_QSFP_PAGE_NUM * MLXSW_QSFP_PAGE_SIZE;
+		mlxsw_qsfp->module_ind[i] = i;
+		eeprom->private = &mlxsw_qsfp->module_ind[i];
+		mlxsw_qsfp->eeprom_attr_list[i] = eeprom;
+		err = sysfs_create_bin_file(&mlxsw_bus_info->dev->kobj,
+					    eeprom);
+		if (err)
+			goto err_create_bin_file;
+	}
+
+	cpld_dev_attr = mlxsw_qsfp->cpld_dev_attrs;
+	for (i = 0; i < mlxsw_qsfp_cpld_num; i++, cpld_dev_attr++) {
+		cpld_dev_attr->show = mlxsw_qsfp_cpld_show;
+		cpld_dev_attr->attr.mode = 0444;
+		cpld_dev_attr->attr.name = devm_kasprintf(mlxsw_bus_info->dev,
+						     GFP_KERNEL,
+						     "cpld%d_version", i + 1);
+		mlxsw_qsfp->cpld_attrs[i] = &cpld_dev_attr->attr;
+		sysfs_attr_init(&cpld_dev_attr->attr);
+		err = sysfs_create_file(&mlxsw_bus_info->dev->kobj,
+					mlxsw_qsfp->cpld_attrs[i]);
+		if (err)
+			goto err_create_cpld_file;
+	}
+
+	*p_qsfp = mlxsw_qsfp;
+
+	return 0;
+
+err_create_cpld_file:
+	sysfs_remove_file(&mlxsw_bus_info->dev->kobj,
+			  mlxsw_qsfp->cpld_attrs[i--]);
+	i = mlxsw_qsfp->module_count;
+err_create_bin_file:
+	sysfs_remove_file(&mlxsw_bus_info->dev->kobj,
+			  mlxsw_qsfp->attrs[i--]);
+err_create_file:
+	while (--i > 0) {
+		sysfs_remove_bin_file(&mlxsw_bus_info->dev->kobj,
+				      mlxsw_qsfp->eeprom_attr_list[i]);
+		sysfs_remove_file(&mlxsw_bus_info->dev->kobj,
+				  mlxsw_qsfp->attrs[i]);
+	}
+
+	return err;
+}
+
+void mlxsw_qsfp_fini(struct mlxsw_qsfp *mlxsw_qsfp)
+{
+	int i;
+
+	if (!strcmp(mlxsw_qsfp->bus_info->device_kind, "i2c"))
+		return;
+
+	for (i = mlxsw_qsfp->module_count - 1; i >= 0; i--) {
+		sysfs_remove_bin_file(&mlxsw_qsfp->bus_info->dev->kobj,
+				      mlxsw_qsfp->eeprom_attr_list[i]);
+		sysfs_remove_file(&mlxsw_qsfp->bus_info->dev->kobj,
+				  mlxsw_qsfp->attrs[i]);
+	}
+}
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Vadim Pasternak <vadimp@mellanox.com>");
+MODULE_DESCRIPTION("Mellanox switch QSFP sysfs driver");
diff --git a/drivers/watchdog/mlx_wdt.c b/drivers/watchdog/mlx_wdt.c
new file mode 100644
index 000000000..74b0622a1
--- /dev/null
+++ b/drivers/watchdog/mlx_wdt.c
@@ -0,0 +1,289 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Mellanox watchdog driver
+ *
+ * Copyright (C) 2019 Mellanox Technologies
+ * Copyright (C) 2019 Michael Shych <mshych@mellanox.com>
+ */
+
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/log2.h>
+#include <linux/module.h>
+#include <linux/platform_data/mlxreg.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/watchdog.h>
+
+#define MLXREG_WDT_CLOCK_SCALE		1000
+#define MLXREG_WDT_MAX_TIMEOUT_TYPE1	32
+#define MLXREG_WDT_MAX_TIMEOUT_TYPE2	255
+#define MLXREG_WDT_MIN_TIMEOUT		1
+#define MLXREG_WDT_OPTIONS_BASE (WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE | \
+				 WDIOF_SETTIMEOUT)
+
+/**
+ * struct mlxreg_wdt - wd private data:
+ *
+ * @wdd:	watchdog device;
+ * @device:	basic device;
+ * @pdata:	data received from platform driver;
+ * @regmap:	register map of parent device;
+ * @timeout:	defined timeout in sec.;
+ * @action_idx:	index for direct access to action register;
+ * @timeout_idx:index for direct access to TO register;
+ * @tleft_idx:	index for direct access to time left register;
+ * @ping_idx:	index for direct access to ping register;
+ * @reset_idx:	index for direct access to reset cause register;
+ * @wd_type:	watchdog HW type;
+ */
+struct mlxreg_wdt {
+	struct watchdog_device wdd;
+	struct mlxreg_core_platform_data *pdata;
+	void *regmap;
+	int action_idx;
+	int timeout_idx;
+	int tleft_idx;
+	int ping_idx;
+	int reset_idx;
+	enum mlxreg_wdt_type wdt_type;
+};
+
+static void mlxreg_wdt_check_card_reset(struct mlxreg_wdt *wdt)
+{
+	struct mlxreg_core_data *reg_data;
+	u32 regval;
+	int rc;
+
+	if (wdt->reset_idx == -EINVAL)
+		return;
+
+	if (!(wdt->wdd.info->options & WDIOF_CARDRESET))
+		return;
+
+	reg_data = &wdt->pdata->data[wdt->reset_idx];
+	rc = regmap_read(wdt->regmap, reg_data->reg, &regval);
+	if (!rc) {
+		if (regval & ~reg_data->mask) {
+			wdt->wdd.bootstatus = WDIOF_CARDRESET;
+			dev_info(wdt->wdd.parent,
+				 "watchdog previously reset the CPU\n");
+		}
+	}
+}
+
+static int mlxreg_wdt_start(struct watchdog_device *wdd)
+{
+	struct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);
+	struct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->action_idx];
+
+	return regmap_update_bits(wdt->regmap, reg_data->reg, ~reg_data->mask,
+				  BIT(reg_data->bit));
+}
+
+static int mlxreg_wdt_stop(struct watchdog_device *wdd)
+{
+	struct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);
+	struct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->action_idx];
+
+	return regmap_update_bits(wdt->regmap, reg_data->reg, ~reg_data->mask,
+				  ~BIT(reg_data->bit));
+}
+
+static int mlxreg_wdt_ping(struct watchdog_device *wdd)
+{
+	struct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);
+	struct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->ping_idx];
+
+	return regmap_update_bits_base(wdt->regmap, reg_data->reg,
+				       ~reg_data->mask, BIT(reg_data->bit),
+				       NULL, false, true);
+}
+
+static int mlxreg_wdt_set_timeout(struct watchdog_device *wdd,
+				  unsigned int timeout)
+{
+	struct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);
+	struct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->timeout_idx];
+	u32 regval, set_time, hw_timeout;
+	int rc;
+
+	if (wdt->wdt_type == MLX_WDT_TYPE1) {
+		rc = regmap_read(wdt->regmap, reg_data->reg, &regval);
+		if (rc)
+			return rc;
+
+		hw_timeout = order_base_2(timeout * MLXREG_WDT_CLOCK_SCALE);
+		regval = (regval & reg_data->mask) | hw_timeout;
+		/* Rowndown to actual closest number of sec. */
+		set_time = BIT(hw_timeout) / MLXREG_WDT_CLOCK_SCALE;
+	} else {
+		set_time = timeout;
+		regval = timeout;
+	}
+
+	wdd->timeout = set_time;
+	rc = regmap_write(wdt->regmap, reg_data->reg, regval);
+
+	if (!rc) {
+		/*
+		 * Restart watchdog with new timeout period
+		 * if watchdog is already started.
+		 */
+		if (watchdog_active(wdd)) {
+			rc = mlxreg_wdt_stop(wdd);
+			if (!rc)
+				rc = mlxreg_wdt_start(wdd);
+		}
+	}
+
+	return rc;
+}
+
+static unsigned int mlxreg_wdt_get_timeleft(struct watchdog_device *wdd)
+{
+	struct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);
+	struct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->tleft_idx];
+	u32 regval;
+	int rc;
+
+	rc = regmap_read(wdt->regmap, reg_data->reg, &regval);
+	/* Return 0 timeleft in case of failure register read. */
+	return rc == 0 ? regval : 0;
+}
+
+static const struct watchdog_ops mlxreg_wdt_ops_type1 = {
+	.start		= mlxreg_wdt_start,
+	.stop		= mlxreg_wdt_stop,
+	.ping		= mlxreg_wdt_ping,
+	.set_timeout	= mlxreg_wdt_set_timeout,
+	.owner		= THIS_MODULE,
+};
+
+static const struct watchdog_ops mlxreg_wdt_ops_type2 = {
+	.start		= mlxreg_wdt_start,
+	.stop		= mlxreg_wdt_stop,
+	.ping		= mlxreg_wdt_ping,
+	.set_timeout	= mlxreg_wdt_set_timeout,
+	.get_timeleft	= mlxreg_wdt_get_timeleft,
+	.owner		= THIS_MODULE,
+};
+
+static const struct watchdog_info mlxreg_wdt_main_info = {
+	.options	= MLXREG_WDT_OPTIONS_BASE
+			| WDIOF_CARDRESET,
+	.identity	= "mlx-wdt-main",
+};
+
+static const struct watchdog_info mlxreg_wdt_aux_info = {
+	.options	= MLXREG_WDT_OPTIONS_BASE
+			| WDIOF_ALARMONLY,
+	.identity	= "mlx-wdt-aux",
+};
+
+static void mlxreg_wdt_config(struct mlxreg_wdt *wdt,
+			      struct mlxreg_core_platform_data *pdata)
+{
+	struct mlxreg_core_data *data = pdata->data;
+	int i;
+
+	wdt->reset_idx = -EINVAL;
+	for (i = 0; i < pdata->counter; i++, data++) {
+		if (strnstr(data->label, "action", sizeof(data->label)))
+			wdt->action_idx = i;
+		else if (strnstr(data->label, "timeout", sizeof(data->label)))
+			wdt->timeout_idx = i;
+		else if (strnstr(data->label, "timeleft", sizeof(data->label)))
+			wdt->tleft_idx = i;
+		else if (strnstr(data->label, "ping", sizeof(data->label)))
+			wdt->ping_idx = i;
+		else if (strnstr(data->label, "reset", sizeof(data->label)))
+			wdt->reset_idx = i;
+	}
+
+	wdt->pdata = pdata;
+	if (strnstr(pdata->identity, mlxreg_wdt_main_info.identity,
+		    sizeof(mlxreg_wdt_main_info.identity)))
+		wdt->wdd.info = &mlxreg_wdt_main_info;
+	else
+		wdt->wdd.info = &mlxreg_wdt_aux_info;
+
+	wdt->wdt_type = pdata->version;
+	if (wdt->wdt_type == MLX_WDT_TYPE2) {
+		wdt->wdd.ops = &mlxreg_wdt_ops_type2;
+		wdt->wdd.max_timeout = MLXREG_WDT_MAX_TIMEOUT_TYPE2;
+	} else {
+		wdt->wdd.ops = &mlxreg_wdt_ops_type1;
+		wdt->wdd.max_timeout = MLXREG_WDT_MAX_TIMEOUT_TYPE1;
+	}
+	wdt->wdd.min_timeout = MLXREG_WDT_MIN_TIMEOUT;
+}
+
+static int mlxreg_wdt_init_timeout(struct mlxreg_wdt *wdt,
+				   struct mlxreg_core_platform_data *pdata)
+{
+	u32 timeout;
+
+	timeout = pdata->data[wdt->timeout_idx].health_cntr;
+	return mlxreg_wdt_set_timeout(&wdt->wdd, timeout);
+}
+
+static int mlxreg_wdt_probe(struct platform_device *pdev)
+{
+	struct mlxreg_core_platform_data *pdata;
+	struct mlxreg_wdt *wdt;
+	int rc;
+
+	pdata = dev_get_platdata(&pdev->dev);
+	if (!pdata) {
+		dev_err(&pdev->dev, "Failed to get platform data.\n");
+		return -EINVAL;
+	}
+	wdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);
+	if (!wdt)
+		return -ENOMEM;
+
+	wdt->wdd.parent = &pdev->dev;
+	wdt->regmap = pdata->regmap;
+	mlxreg_wdt_config(wdt, pdata);
+
+	if ((pdata->features & MLXREG_CORE_WD_FEATURE_NOWAYOUT))
+		watchdog_set_nowayout(&wdt->wdd, WATCHDOG_NOWAYOUT);
+	watchdog_stop_on_reboot(&wdt->wdd);
+	watchdog_set_drvdata(&wdt->wdd, wdt);
+	rc = mlxreg_wdt_init_timeout(wdt, pdata);
+	if (rc)
+		goto register_error;
+
+	if ((pdata->features & MLXREG_CORE_WD_FEATURE_START_AT_BOOT)) {
+		rc = mlxreg_wdt_start(&wdt->wdd);
+		if (rc)
+			goto register_error;
+		set_bit(WDOG_HW_RUNNING, &wdt->wdd.status);
+	}
+	mlxreg_wdt_check_card_reset(wdt);
+	rc = devm_watchdog_register_device(&pdev->dev, &wdt->wdd);
+
+register_error:
+	if (rc)
+		dev_err(&pdev->dev,
+			"Cannot register watchdog device (err=%d)\n", rc);
+	return rc;
+}
+
+static struct platform_driver mlxreg_wdt_driver = {
+	.probe	= mlxreg_wdt_probe,
+	.driver	= {
+			.name = "mlx-wdt",
+	},
+};
+
+module_platform_driver(mlxreg_wdt_driver);
+
+MODULE_AUTHOR("Michael Shych <michaelsh@mellanox.com>");
+MODULE_DESCRIPTION("Mellanox watchdog driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:mlx-wdt");
-- 
2.20.1

